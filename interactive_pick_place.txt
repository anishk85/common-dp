#!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from geometry_msgs.msg import PoseStamped, Pose, Point, Quaternion
from std_msgs.msg import Bool
from sensor_msgs.msg import Image, JointState
from moveit_msgs.action import MoveGroup
from moveit_msgs.msg import MoveGroupGoal, Constraints, JointConstraint, PositionConstraint, OrientationConstraint
from moveit_msgs.msg import RobotState, PlanningScene, CollisionObject
from moveit_msgs.srv import GetPlanningScene, GetPositionIK, GetPositionFK
from shape_msgs.msg import SolidPrimitive
from cv_bridge import CvBridge
import cv2
import numpy as np
import threading
import time
import math

class InteractivePickPlaceController(Node):
    def __init__(self):
        super().__init__('interactive_pick_place_controller')
        
        # CV Bridge
        self.bridge = CvBridge()
        
        # Publishers
        self.electromagnet_pub = self.create_publisher(Bool, '/thor_arm/electromagnet/control', 10)
        self.planning_scene_pub = self.create_publisher(PlanningScene, '/planning_scene', 10)
        
        # Action clients
        self.move_group_client = ActionClient(self, MoveGroup, '/move_action')
        
        # Service clients
        self.get_planning_scene_client = self.create_client(GetPlanningScene, '/get_planning_scene')
        self.get_position_ik_client = self.create_client(GetPositionIK, '/compute_ik')
        self.get_position_fk_client = self.create_client(GetPositionFK, '/compute_fk')
        
        # Subscribers
        self.image_sub = self.create_subscription(
            Image, '/camera/image_raw', self.image_callback, 10)
        
        self.joint_states_sub = self.create_subscription(
            JointState, '/joint_states', self.joint_states_callback, 10)
        
        # State variables
        self.current_image = None
        self.current_joint_states = None
        self.selected_point = None
        self.movement_in_progress = False
        self.electromagnet_active = False
        
        # MoveIt configuration
        self.group_name = "arm_group"
        self.planning_frame = "base_link"
        self.end_effector_link = "electromagnet_plate"
        
        # Joint names
        self.joint_names = ['joint_1', 'joint_2', 'joint_3', 'joint_4', 'joint_5', 'joint_6']
        
        # Predefined positions
        self.home_position = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
        self.scan_position = [0.0, -0.5, 0.3, 0.0, 0.2, 0.0]
        
        # Camera calibration (adjust these based on your camera setup)
        self.camera_pos = [0.5, 0.0, 1.5]  # Camera position in world frame
        self.camera_fov = 1.047  # Field of view in radians
        self.table_height = 0.8  # Table height in meters
        
        # GUI thread
        self.gui_thread = threading.Thread(target=self.run_gui)
        self.gui_thread.daemon = True
        self.gui_thread.start()
        
        # Wait for services
        self.create_timer(2.0, self.initialize_system)
        
        self.get_logger().info("üéØ Interactive Pick & Place Controller with MoveIt started")
        self.get_logger().info("üì± GUI window will open - click on objects to pick them!")
    
    def initialize_system(self):
        """Initialize MoveIt and move to scan position"""
        if not self.move_group_client.wait_for_server(timeout_sec=1.0):
            self.get_logger().warn("‚ö†Ô∏è Waiting for MoveIt action server...")
            return
        
        # Add table to planning scene
        self.add_table_to_planning_scene()
        
        # Move to scan position
        self.move_to_scan_position()
    
    def add_table_to_planning_scene(self):
        """Add table as collision object to planning scene"""
        planning_scene = PlanningScene()
        planning_scene.is_diff = True
        
        # Create table collision object
        table = CollisionObject()
        table.id = "table"
        table.header.frame_id = self.planning_frame
        
        # Table pose
        table_pose = Pose()
        table_pose.position.x = 0.0
        table_pose.position.y = 0.0
        table_pose.position.z = self.table_height / 2
        table_pose.orientation.w = 1.0
        
        # Table shape
        table_primitive = SolidPrimitive()
        table_primitive.type = SolidPrimitive.BOX
        table_primitive.dimensions = [1.0, 1.0, self.table_height]  # 1m x 1m x table_height
        
        table.primitives.append(table_primitive)
        table.primitive_poses.append(table_pose)
        table.operation = CollisionObject.ADD
        
        planning_scene.world.collision_objects.append(table)
        self.planning_scene_pub.publish(planning_scene)
        
        self.get_logger().info("üè¢ Added table to planning scene")
    
    def image_callback(self, msg):
        """Store latest image"""
        try:
            self.current_image = self.bridge.imgmsg_to_cv2(msg, "bgr8")
        except Exception as e:
            self.get_logger().error(f"‚ùå Image conversion error: {e}")
    
    def joint_states_callback(self, msg):
        """Store joint states"""
        self.current_joint_states = msg
    
    def move_to_scan_position(self):
        """Move to scan position using MoveIt"""
        if not self.movement_in_progress:
            self.get_logger().info("üîç Moving to scan position...")
            self.move_to_joint_positions(self.scan_position)
    
    def run_gui(self):
        """Run the GUI for object selection"""
        cv2.namedWindow('Thor Camera - Click to Pick Objects', cv2.WINDOW_NORMAL)
        cv2.resizeWindow('Thor Camera - Click to Pick Objects', 800, 600)
        cv2.setMouseCallback('Thor Camera - Click to Pick Objects', self.mouse_callback)
        
        while True:
            if self.current_image is not None:
                display_image = self.current_image.copy()
                
                # Add instructions
                cv2.putText(display_image, "Click on object to pick it up!", 
                           (10, 30), cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 0), 2)
                cv2.putText(display_image, f"Magnet: {'ON' if self.electromagnet_active else 'OFF'}", 
                           (10, 60), cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 255, 255), 2)
                cv2.putText(display_image, "Controls: h=home, s=scan, m=magnet, r=reset, q=quit", 
                           (10, 90), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 1)
                
                # Show selected point
                if self.selected_point is not None:
                    x, y = self.selected_point
                    cv2.circle(display_image, (x, y), 20, (0, 0, 255), 3)
                    cv2.putText(display_image, "TARGET", (x+25, y), 
                               cv2.FONT_HERSHEY_SIMPLEX, 0.6, (0, 0, 255), 2)
                
                # Show movement status
                if self.movement_in_progress:
                    cv2.putText(display_image, "MOVING...", 
                               (10, display_image.shape[0] - 20), 
                               cv2.FONT_HERSHEY_SIMPLEX, 0.8, (0, 255, 255), 2)
                
                cv2.imshow('Thor Camera - Click to Pick Objects', display_image)
                
                key = cv2.waitKey(1) & 0xFF
                if key == ord('q'):
                    break
                elif key == ord('h'):
                    self.get_logger().info("üè† Moving to home position...")
                    self.move_to_joint_positions(self.home_position)
                elif key == ord('s'):
                    self.get_logger().info("üîç Moving to scan position...")
                    self.move_to_joint_positions(self.scan_position)
                elif key == ord('m'):
                    self.toggle_electromagnet()
                elif key == ord('r'):
                    self.selected_point = None
                    
            else:
                # Show waiting message
                waiting_image = np.zeros((480, 640, 3), dtype=np.uint8)
                cv2.putText(waiting_image, "Waiting for camera...", 
                           (200, 240), cv2.FONT_HERSHEY_SIMPLEX, 1, (255, 255, 255), 2)
                cv2.imshow('Thor Camera - Click to Pick Objects', waiting_image)
                cv2.waitKey(100)
        
        cv2.destroyAllWindows()
    
    def mouse_callback(self, event, x, y, flags, param):
        """Handle mouse clicks"""
        if event == cv2.EVENT_LBUTTONDOWN and not self.movement_in_progress:
            self.selected_point = (x, y)
            self.get_logger().info(f"üéØ Selected point: ({x}, {y})")
            
            # Convert pixel to world coordinates
            world_pos = self.pixel_to_world(x, y)
            self.get_logger().info(f"üìç Estimated world position: {world_pos}")
            
            # Start pick and place sequence
            self.start_pick_and_place_sequence(world_pos)
    
    def pixel_to_world(self, pixel_x, pixel_y):
        """Convert pixel coordinates to world coordinates"""
        if self.current_image is None:
            return (0, 0, self.table_height + 0.05)
        
        img_height, img_width = self.current_image.shape[:2]
        
        # Normalize pixel coordinates to [-1, 1]
        norm_x = (pixel_x - img_width/2) / (img_width/2)
        norm_y = (pixel_y - img_height/2) / (img_height/2)
        
        # Calculate world coordinates based on camera position and FOV
        # Assuming camera is looking down at table
        camera_height = self.camera_pos[2] - self.table_height
        half_fov = self.camera_fov / 2
        
        # Calculate the real-world size of the image at table level
        table_half_width = camera_height * math.tan(half_fov)
        
        # Convert to world coordinates
        world_x = norm_x * table_half_width
        world_y = norm_y * table_half_width
        world_z = self.table_height + 0.05  # Slightly above table
        
        return (world_x, world_y, world_z)
    
    def start_pick_and_place_sequence(self, target_pos):
        """Start automated pick and place sequence using MoveIt"""
        if self.movement_in_progress:
            return
        
        self.get_logger().info("üöÄ Starting MoveIt pick and place sequence...")
        
        # Execute sequence in separate thread
        sequence_thread = threading.Thread(target=self.execute_pick_and_place, args=(target_pos,))
        sequence_thread.daemon = True
        sequence_thread.start()
    
    def execute_pick_and_place(self, target_pos):
        """Execute the full pick and place sequence"""
        try:
            # Step 1: Move to pre-pickup position (above target)
            pre_pickup_pos = (target_pos[0], target_pos[1], target_pos[2] + 0.1)
            self.get_logger().info("üéØ Step 1: Moving to pre-pickup position...")
            if not self.move_to_pose(pre_pickup_pos, (0, 0, 0, 1)):
                self.get_logger().error("‚ùå Failed to reach pre-pickup position")
                return
            
            # Step 2: Move to pickup position
            self.get_logger().info("üìç Step 2: Moving to pickup position...")
            if not self.move_to_pose(target_pos, (0, 0, 0, 1)):
                self.get_logger().error("‚ùå Failed to reach pickup position")
                return
            
            # Step 3: Activate electromagnet
            self.get_logger().info("üß≤ Step 3: Activating electromagnet...")
            self.activate_electromagnet()
            time.sleep(2)
            
            # Step 4: Lift object
            lift_pos = (target_pos[0], target_pos[1], target_pos[2] + 0.2)
            self.get_logger().info("‚¨ÜÔ∏è Step 4: Lifting object...")
            if not self.move_to_pose(lift_pos, (0, 0, 0, 1)):
                self.get_logger().error("‚ùå Failed to lift object")
                return
            
            # Step 5: Move to place position
            place_pos = (target_pos[0] + 0.3, target_pos[1], target_pos[2] + 0.2)
            self.get_logger().info("üì¶ Step 5: Moving to place position...")
            if not self.move_to_pose(place_pos, (0, 0, 0, 1)):
                self.get_logger().error("‚ùå Failed to reach place position")
                return
            
            # Step 6: Lower to place
            final_place_pos = (place_pos[0], place_pos[1], target_pos[2])
            self.get_logger().info("‚¨áÔ∏è Step 6: Lowering to place...")
            if not self.move_to_pose(final_place_pos, (0, 0, 0, 1)):
                self.get_logger().error("‚ùå Failed to lower to place")
                return
            
            # Step 7: Deactivate electromagnet
            self.get_logger().info("‚ö´ Step 7: Releasing object...")
            self.deactivate_electromagnet()
            time.sleep(1)
            
            # Step 8: Return to scan position
            self.get_logger().info("üîÑ Step 8: Returning to scan position...")
            self.move_to_joint_positions(self.scan_position)
            
            self.get_logger().info("‚úÖ Pick and place sequence completed successfully!")
            self.selected_point = None
            
        except Exception as e:
            self.get_logger().error(f"‚ùå Pick and place sequence failed: {e}")
            self.selected_point = None
    
    def move_to_pose(self, position, orientation):
        """Move end effector to target pose using MoveIt"""
        self.movement_in_progress = True
        
        try:
            # Create pose goal
            pose_goal = Pose()
            pose_goal.position.x = position[0]
            pose_goal.position.y = position[1]
            pose_goal.position.z = position[2]
            pose_goal.orientation.x = orientation[0]
            pose_goal.orientation.y = orientation[1]
            pose_goal.orientation.z = orientation[2]
            pose_goal.orientation.w = orientation[3]
            
            # Create MoveGroup goal
            goal = MoveGroup.Goal()
            goal.request.group_name = self.group_name
            goal.request.num_planning_attempts = 10
            goal.request.allowed_planning_time = 5.0
            goal.request.planner_id = "RRTConnect"
            
            # Set pose target
            pose_constraint = PositionConstraint()
            pose_constraint.header.frame_id = self.planning_frame
            pose_constraint.link_name = self.end_effector_link
            pose_constraint.target_point_offset.x = 0.0
            pose_constraint.target_point_offset.y = 0.0
            pose_constraint.target_point_offset.z = 0.0
            
            # Create goal constraint
            goal_constraint = Constraints()
            goal_constraint.name = "pose_constraint"
            goal_constraint.position_constraints.append(pose_constraint)
            
            goal.request.goal_constraints.append(goal_constraint)
            
            # Send goal
            future = self.move_group_client.send_goal_async(goal)
            goal_handle = future.result()
            
            if not goal_handle.accepted:
                self.get_logger().error("‚ùå MoveIt goal rejected")
                return False
            
            # Wait for result
            result_future = goal_handle.get_result_async()
            result = result_future.result()
            
            if result.result.error_code.val == 1:  # SUCCESS
                self.get_logger().info("‚úÖ MoveIt motion completed successfully")
                return True
            else:
                self.get_logger().error(f"‚ùå MoveIt motion failed: {result.result.error_code.val}")
                return False
                
        except Exception as e:
            self.get_logger().error(f"‚ùå MoveIt motion error: {e}")
            return False
        finally:
            self.movement_in_progress = False
    
    def move_to_joint_positions(self, joint_positions):
        """Move to joint positions using MoveIt"""
        self.movement_in_progress = True
        
        try:
            # Create MoveGroup goal
            goal = MoveGroup.Goal()
            goal.request.group_name = self.group_name
            goal.request.num_planning_attempts = 10
            goal.request.allowed_planning_time = 5.0
            goal.request.planner_id = "RRTConnect"
            
            # Set joint constraints
            joint_constraints = []
            for i, joint_name in enumerate(self.joint_names):
                constraint = JointConstraint()
                constraint.joint_name = joint_name
                constraint.position = joint_positions[i]
                constraint.tolerance_above = 0.01
                constraint.tolerance_below = 0.01
                constraint.weight = 1.0
                joint_constraints.append(constraint)
            
            goal_constraint = Constraints()
            goal_constraint.name = "joint_constraint"
            goal_constraint.joint_constraints = joint_constraints
            
            goal.request.goal_constraints.append(goal_constraint)
            
            # Send goal
            future = self.move_group_client.send_goal_async(goal)
            goal_handle = future.result()
            
            if not goal_handle.accepted:
                self.get_logger().error("‚ùå MoveIt joint goal rejected")
                return False
            
            # Wait for result
            result_future = goal_handle.get_result_async()
            result = result_future.result()
            
            if result.result.error_code.val == 1:  # SUCCESS
                self.get_logger().info("‚úÖ MoveIt joint motion completed")
                return True
            else:
                self.get_logger().error(f"‚ùå MoveIt joint motion failed: {result.result.error_code.val}")
                return False
                
        except Exception as e:
            self.get_logger().error(f"‚ùå MoveIt joint motion error: {e}")
            return False
        finally:
            self.movement_in_progress = False
    
    def activate_electromagnet(self):
        """Activate electromagnet"""
        self.electromagnet_active = True
        msg = Bool()
        msg.data = True
        self.electromagnet_pub.publish(msg)
        self.get_logger().info("üß≤ Electromagnet ACTIVATED")
    
    def deactivate_electromagnet(self):
        """Deactivate electromagnet"""
        self.electromagnet_active = False
        msg = Bool()
        msg.data = False
        self.electromagnet_pub.publish(msg)
        self.get_logger().info("‚ö´ Electromagnet DEACTIVATED")
    
    def toggle_electromagnet(self):
        """Toggle electromagnet"""
        if self.electromagnet_active:
            self.deactivate_electromagnet()
        else:
            self.activate_electromagnet()

def main(args=None):
    rclpy.init(args=args)
    node = InteractivePickPlaceController()
    
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()

























    #!/usr/bin/env python3

import rclpy
from rclpy.node import Node
from rclpy.action import ActionClient
from geometry_msgs.msg import PoseStamped
from std_msgs.msg import Bool
from sensor_msgs.msg import JointState
from control_msgs.action import FollowJointTrajectory
from trajectory_msgs.msg import JointTrajectory, JointTrajectoryPoint
import time
import threading

class PickPlaceController(Node):
    def __init__(self):
        super().__init__('pick_place_controller')
        
        # Publishers
        self.electromagnet_pub = self.create_publisher(Bool, '/electromagnet_control', 10)
        self.status_pub = self.create_publisher(Bool, '/electromagnet_status', 10)
        
        # Action client
        self.joint_trajectory_client = ActionClient(
            self, FollowJointTrajectory, '/arm_group_controller/follow_joint_trajectory')
        
        # Subscribers
        self.joint_states_sub = self.create_subscription(
            JointState, '/joint_states', self.joint_states_callback, 10)
        
        self.detected_objects_sub = self.create_subscription(
            PoseStamped, '/perception/detected_objects', self.detected_objects_callback, 10)
        
        # State variables
        self.current_joint_states = None
        self.detected_objects = []
        self.electromagnet_active = False
        self.task_running = False
        self.sequence_step = 0
        self.movement_in_progress = False
        
        # IMPROVED: Better joint positions for actual robot workspace
        self.joint_names = ['joint_1', 'joint_2', 'joint_3', 'joint_4', 'joint_5', 'joint_6']
        
        # FIXED: More realistic joint positions (in radians)
        # self.home_position = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
        # self.scan_position = [0.0, -0.5, 0.3, 0.0, 0.2, 0.0]      # Look down at workspace
        # self.pickup_position = [0.0, -0.8, 0.8, 0.0, 0.0, 0.0]    # Lower to pickup
        # self.place_position = [1.2, -0.8, 0.8, 0.0, 0.0, 0.0]     # Move to place location
         self.home_position = [0.0, 0.0, 0.0, 0.0, 0.0, 0.0]
        self.scan_position = [0.0, -1.0, 0.8, 0.0, 0.5, 0.0]      # Better scan position
        self.pickup_position = [0.0, -1.3, 1.2, 0.0, 0.8, 0.0]    # Lower for pickup
        self.place_position = [1.5, -1.3, 1.2, 0.0, 0.8, 0.0]     # Move to place
        # Status timer
        self.status_timer = self.create_timer(0.1, self.publish_status)
        
        # Wait for services
        self.create_timer(2.0, self.start_sequence)
        
        self.get_logger().info("ü§ñ Pick and Place Controller initialized")
    
    def joint_states_callback(self, msg):
        self.current_joint_states = msg
    
    def detected_objects_callback(self, msg):
        # Only store recent objects
        self.detected_objects.append(msg)
        if len(self.detected_objects) > 10:
            self.detected_objects.pop(0)
    
    def publish_status(self):
        msg = Bool()
        msg.data = self.electromagnet_active
        self.status_pub.publish(msg)
    
    def start_sequence(self):
        """Start the pick and place sequence"""
        if self.task_running or self.movement_in_progress:
            return
            
        if not self.joint_trajectory_client.wait_for_server(timeout_sec=1.0):
            self.get_logger().warn("‚ö†Ô∏è Waiting for action server...")
            return
            
        if self.current_joint_states is None:
            self.get_logger().warn("‚ö†Ô∏è No joint states received yet...")
            return
        
        self.get_logger().info("üöÄ Starting pick and place sequence")
        self.task_running = True
        self.sequence_step = 0
        self.execute_next_step()
    
    def execute_next_step(self):
        """Execute the next step in the sequence"""
        if not self.task_running or self.movement_in_progress:
            return
            
        if self.sequence_step == 0:
            self.get_logger().info("üîç Step 1: Moving to scan position...")
            self.move_to_position(self.scan_position)
            
        elif self.sequence_step == 1:
            self.get_logger().info("üì∑ Step 2: Scanning for objects...")
            self.scan_for_objects()
            
        elif self.sequence_step == 2:
            self.get_logger().info("üìç Step 3: Moving to pickup position...")
            self.move_to_position(self.pickup_position)
            
        elif self.sequence_step == 3:
            self.get_logger().info("üß≤ Step 4: Activating electromagnet...")
            self.activate_electromagnet()
            self.create_timer(2.0, self.timer_callback_once)  # Wait 2 seconds
            
        elif self.sequence_step == 4:
            self.get_logger().info("üì¶ Step 5: Moving to place position...")
            self.move_to_position(self.place_position)
            
        elif self.sequence_step == 5:
            self.get_logger().info("üîì Step 6: Releasing object...")
            self.deactivate_electromagnet()
            self.create_timer(2.0, self.timer_callback_once)  # Wait 2 seconds
            
        elif self.sequence_step == 6:
            self.get_logger().info("üè† Step 7: Returning home...")
            self.move_to_position(self.home_position)
            
        elif self.sequence_step == 7:
            self.get_logger().info("‚úÖ Sequence complete! Restarting in 5 seconds...")
            self.task_running = False
            self.sequence_step = 0
            self.detected_objects.clear()
            self.create_timer(5.0, self.timer_callback_once)  # Restart after 5 seconds
    
    def timer_callback_once(self):
        """Single-use timer callback"""
        if not self.task_running:
            # Restart sequence
            self.start_sequence()
        else:
            # Continue to next step
            self.sequence_step += 1
            self.execute_next_step()
    
    def scan_for_objects(self):
        """Scan for objects and decide next action"""
        if len(self.detected_objects) > 0:
            self.get_logger().info(f"üéØ Found {len(self.detected_objects)} objects!")
            self.sequence_step += 1
            self.execute_next_step()
        else:
            self.get_logger().info("‚ö†Ô∏è No objects found, waiting 3 seconds...")
            self.create_timer(3.0, self.timer_callback_once)
    
    def move_to_position(self, target_positions):
        """Move robot to target position"""
        if self.movement_in_progress:
            self.get_logger().warn("‚ö†Ô∏è Movement already in progress!")
            return
            
        self.movement_in_progress = True
        
        # Create trajectory goal
        goal = FollowJointTrajectory.Goal()
        goal.trajectory.joint_names = self.joint_names
        goal.trajectory.header.stamp = self.get_clock().now().to_msg()
        
        # Create trajectory point
        point = JointTrajectoryPoint()
        point.positions = target_positions
        point.velocities = [0.0] * len(self.joint_names)
        point.accelerations = [0.0] * len(self.joint_names)
        point.time_from_start.sec = 5  # 5 seconds for movement
        point.time_from_start.nanosec = 0
        
        goal.trajectory.points = [point]
        
        self.get_logger().info(f"üéØ Moving to: {[f'{pos:.2f}' for pos in target_positions]}")
        
        # Send goal
        future = self.joint_trajectory_client.send_goal_async(goal)
        future.add_done_callback(self.goal_response_callback)
    
    def goal_response_callback(self, future):
        """Handle goal response"""
        goal_handle = future.result()
        if not goal_handle.accepted:
            self.get_logger().error("‚ùå Goal rejected!")
            self.movement_in_progress = False
            return
            
        self.get_logger().info("‚úÖ Goal accepted, waiting for result...")
        result_future = goal_handle.get_result_async()
        result_future.add_done_callback(self.result_callback)
    
    def result_callback(self, future):
        """Handle movement result"""
        self.movement_in_progress = False
        result = future.result().result
        
        if result.error_code == 0:
            self.get_logger().info("‚úÖ Movement completed successfully!")
            self.sequence_step += 1
            # Wait a bit before next step
            self.create_timer(1.0, self.timer_callback_once)
        else:
            self.get_logger().error(f"‚ùå Movement failed with error: {result.error_code}")
            self.task_running = False
    
    def activate_electromagnet(self):
        """Activate electromagnet"""
        self.electromagnet_active = True
        msg = Bool()
        msg.data = True
        self.electromagnet_pub.publish(msg)
        self.get_logger().info("üß≤ Electromagnet ACTIVATED")
    
    def deactivate_electromagnet(self):
        """Deactivate electromagnet"""
        self.electromagnet_active = False
        msg = Bool()
        msg.data = False
        self.electromagnet_pub.publish(msg)
        self.get_logger().info("‚ö´ Electromagnet DEACTIVATED")

def main(args=None):
    rclpy.init(args=args)
    node = PickPlaceController()
    
    try:
        rclpy.spin(node)
    except KeyboardInterrupt:
        pass
    finally:
        node.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()









ros2 topic list | grep depth
/depth/camera_info
/depth/image_raw
/depth/image_raw/compressed
/depth/image_raw/compressedDepth
/depth/image_raw/theora
anish@anish-OMEN-by-HP-Gaming-Laptop-16-xd0xxx:~/dp_ws/Thor-ROS/ws_thor$ ros2 topic list | grep move_group
anish@anish-OMEN-by-HP-Gaming-Laptop-16-xd0xxx:~/dp_ws/Thor-ROS/ws_thor$ ros2 pkg list | grep moveit
moveit
moveit_common
moveit_configs_utils
moveit_core
moveit_kinematics
moveit_msgs
moveit_planners
moveit_planners_chomp
moveit_planners_ompl
moveit_plugins
moveit_resources
moveit_resources_fanuc_description
moveit_resources_fanuc_moveit_config
moveit_resources_gazebo
moveit_resources_panda_description
moveit_resources_panda_moveit_config
moveit_resources_pr2_description
moveit_ros
moveit_ros_benchmarks
moveit_ros_move_group
moveit_ros_occupancy_map_monitor
moveit_ros_planning
moveit_ros_planning_interface
moveit_ros_robot_interaction
moveit_ros_visualization
moveit_ros_warehouse
moveit_servo
moveit_setup_app_plugins
moveit_setup_assistant
moveit_setup_controllers
moveit_setup_core_plugins
moveit_setup_framework
moveit_setup_srdf_plugins
moveit_simple_controller_manager
moveit_task_constructor_msgs
moveit_visual_tools
mycobot_moveit_config
mycobot_moveit_demos
panda_moveit_config
turtlebot3_manipulation_moveit_config